<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Tool and Video Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>
    <style>
        h3{
            color: #ffffff;
            padding-left: 80px;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color:#485056;
        }
        .tools {
            position: fixed;
            top: 10px;
            left: 40%;
            z-index: 1000;
            background-color:#485056;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .tools button {
            margin: 5px;
            padding: 5px;
            cursor: pointer;
            background-color: #d5b211;
            
        }
        .tools button:hover {
             background-color: #e0e0e0; 
        }
        .tools button img {
            width: 20px;
            height: 20px;
            
        }
        #video-container {
            width: 80%; /* Adjust width as needed */
            max-width: 800px; /* Limit maximum width */
            padding-top: 600px;
            text-align: center; /* Center align video container */
            position: relative;
            margin: 20px auto; /* Center horizontally with some top margin */
    
        }
        video {
            width: 100%;
            display: block; /* Ensure video fills its container */
            
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* Ensure video controls are not obstructed */
        }
        .annotations {
            position: fixed;
            right: 10px;
            top: 10px;
            width: 250px;
            background-color: #0f0e0e;
            border: 0.5px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            text-shadow: #d5b211;
            padding-right: 35px;
            height: 100%;
            overflow-y: auto;
        }

        .annotations ul li {
            color: white; /* Set the color of list items to white */
        }
        
        .annotation-item {
            background-color: black;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            color: white; /* Text color inside the annotation box */
        }
        .annotation-item input {
            width: calc(100% - 20px); /* Adjust the width of the input box */
            margin-top: 10px; /* Add some margin to the top */
        }
        .annotation-buttons {
            text-align: right;
            margin-top: 5px;
        }
        .annotation-buttons button {
            margin-left: 5px;
        }

        .timeline {
            position: relative; /* Make timeline relative to its container */
            width: 80%; /* Fill the width of its container */
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-top: 20px; /* Add some space between video container and timeline */
            overflow: hidden; /* Hide overflow to prevent extra horizontal scroll */
        }
        .timeline .tick {
            display: inline-block;
            width: calc(100% / var(--duration)); /* Adjust width dynamically based on video duration */
            height: 20px;
            background-color: #ccc;
            margin: 0;
            cursor: pointer;
            position: relative;
        }
        .timeline .tick .icon {
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }
        .timeline .tick.has-drawing .icon {
            display: block;
        }
        .timeline .tick.has-drawing .icon img {
            width: 16px;
            height: 16px;
        }
        #pencil-pointer {
            position: absolute;
            display: none; /* Initially hide the pointer */
            width: 20px; /* Adjust width and height as needed */
            height: 20px;
            background-image: url('https://w7.pngwing.com/pngs/314/397/png-transparent-location-pointer-pin-google-map-red-thumbnail.png'); /* Path to your pointer image */
            background-size: cover; /* Ensure the image covers the div */
            z-index: 999; /* Ensure it's above other elements */
        }
    </style>
</head>
<body>
    <!-- Drawing Tools -->
    <div class="tools">
        <button onclick="drawFreehand()"><img src="icons/freehand.png" alt="Freehand"></button>
        <button onclick="activateRectangleMode()"><img src="icons/rectangle.png" alt="Rectangle"></button>
        <button onclick="activateTextMode()"><img src="icons/text.png" alt="Text"></button>
        <button onclick="activateNoteMode()"><img src="icons/notes.png" alt="Note"></button>
        <button onclick="useEraser()"><img src="icons/eraser.png" alt="Eraser"></button>
        <button onclick="undo()"><img src="icons/undo.png" alt="Undo"></button>
        <button onclick="redo()"><img src="icons/redo.png" alt="Redo"></button>
        <button onclick="unpickTool()"><img src="icons/unpick.png" alt="Unpick"></button>
    </div>

    <!-- Fabric.js Canvas -->
    <div id="video-container">
        <video id="video" controls></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- Annotations Sidebar -->
    <div class="annotations">
        <h3>Annotations</h3>
        <ul id="annotations-list"></ul>
    </div>

    <!-- Timeline -->
    <div class="timeline" id="timeline"></div>

    <div id="pencil-pointer"></div>

    <!-- Shaka Player -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/3.1.0/shaka-player.compiled.js"></script>

    <script>
        let annotations = [];
        let currentColorIndex = 0;
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];

        // Initialize Shaka Player
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('video');
            const player = new shaka.Player(video);
            const manifestUri = 'https://storage.googleapis.com/shaka-demo-assets/angel-one/dash.mpd';

            player.load(manifestUri).then(function() {
                console.log('The video has now been loaded!');
                setupTimeline(video);
            }).catch(function(error) {
                console.error('Error code', error.code, 'object', error);
            });
        });

        function setupTimeline(video) {
            const timeline = document.getElementById('timeline');
            const duration = Math.floor(video.duration);
            timeline.style.setProperty('--duration', duration); // Set custom CSS property for dynamic width

            for (let i = 0; i < duration; i++) {
                const tick = document.createElement('div');
                tick.classList.add('tick');
                tick.dataset.time = i; // Set the dataset.time attribute

                // Add pencil icon and setup drag events
                const icon = document.createElement('div');
                icon.classList.add('icon');
                const img = document.createElement('img');
                img.src = 'icons/pencil.png';
                img.alt = 'Pencil';
                icon.appendChild(img);
                tick.appendChild(icon);

                tick.addEventListener('click', function() {
                    console.log(`Clicked on tick at ${i} seconds.`);
                    video.currentTime = i;
                });

                // Add drag events to the pencil icon
                img.addEventListener('dragstart', handleDragStart);
                tick.addEventListener('dragover', handleDragOver);
                tick.addEventListener('drop', handleDrop);
                img.setAttribute('draggable', true);

                timeline.appendChild(tick);
            }
        }

          // Function to handle drag start
          function handleDragStart(event) {
            const dragTime = event.target.parentNode.parentNode.dataset.time;
            console.log('Drag start:', dragTime);
            event.dataTransfer.setData('text/plain', dragTime);
        }

        function handleDragOver(event) {
            console.log('Drag over:', event.target.dataset.time);
            event.preventDefault();
        }

        function handleDrop(event) {
    console.log('Drop:', event.target.dataset.time);
    event.preventDefault();
    const oldTime = event.dataTransfer.getData('text/plain');
    const newTime = event.target.dataset.time;
    moveAnnotation(oldTime, newTime);

    // Remove the pencil icon from the old tick
    const oldTick = document.querySelector(`.tick[data-time='${oldTime}'] .icon`);
    if (oldTick) {
        oldTick.style.display = 'none';
    }

    const annotationIndex = annotations.findIndex(annotation => Math.floor(annotation.time) === parseInt(oldTime));
    if (annotationIndex !== -1) {
        annotations.splice(annotationIndex, 1);
        updateAnnotationsList();
        updateTimelineIcons();
    }
}


        
// Fabric.js Canvas Initialization
const canvas = new fabric.Canvas('canvas', {
    selection: false,
    isDrawingMode: false
});

function moveAnnotation(oldTime, newTime) {
    console.log('Moving annotation from', oldTime, 'to', newTime);
    oldTime = parseInt(oldTime);
    newTime = parseInt(newTime);

    // Find the annotation to move
    let annotationIndex = annotations.findIndex(annotation => Math.floor(annotation.time) === oldTime);
    if (annotationIndex !== -1) {
        const annotation = annotations[annotationIndex];
        annotation.time = newTime;
        annotations.splice(annotationIndex, 1, annotation); // Update annotation time in the array

        // Remove the annotation from the canvas at the old time
        canvas.forEachObject(obj => {
            if (obj.time === oldTime) {
                canvas.remove(obj);
            }
        });

        // Load the annotation onto the canvas at the new time
        annotations.forEach(ann => {
            if (Math.floor(ann.time) === newTime) {
                canvas.loadFromJSON(ann.content, () => {
                    canvas.renderAll();
                });
            }
        });

        // Update UI or canvas accordingly
        updateAnnotationsList();
        updateTimelineIcons();
    }
}




        // Set the current drawing color
        function setCurrentDrawingColor() {
            if (canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = colors[currentColorIndex % colors.length];
                currentColorIndex++;
            }
        }

        // Drawing functionality
        let drawingMode = '';
        let isDrawing = false;

        function drawFreehand() {
            canvas.isDrawingMode = true;
            drawingMode = '';
            setCurrentDrawingColor(); // Set new color for each new drawing
        }

        function activateRectangleMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'rectangle';
            setCurrentDrawingColor(); // Set new color for each new drawing
        }

        function activateTextMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'text';
            const text = new fabric.Textbox('Type here', {
                left: 50,
                top: 50,
                fontSize: 20,
                fontFamily: 'Arial',
                fill: colors[currentColorIndex % colors.length],
                width: 200
            });
            currentColorIndex++;
            canvas.add(text).setActiveObject(text);
        }

        function activateNoteMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'note';
            const note = new fabric.Textbox('Note here', {
                left: 50,
                top: 50,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: colors[currentColorIndex % colors.length],
                backgroundColor: '#ffffcc',
                width: 200
            });
            currentColorIndex++;
            canvas.add(note).setActiveObject(note);
        }

        function useEraser() {
            canvas.isDrawingMode = false;
            canvas.on('mouse:down', function(event) {
                if (event.target) {
                    canvas.remove(event.target);
                }
            });
        }
        // Function to unpick tool
        function unpickTool() {
            canvas.isDrawingMode = false;
            canvas.defaultCursor = 'default';
            canvas.selection = true;
        }

        canvas.on('mouse:down', function(opt) {
            if (drawingMode === 'rectangle') {
                isDrawing = true;
                const pointer = canvas.getPointer(opt.e);
                const rect = new fabric.Rect({
                    left: pointer.x,
                    top: pointer.y,
                    width: 0,
                    height: 0,
                    fill: 'transparent',
                    stroke: colors[currentColorIndex % colors.length],
                    strokeWidth: 2
                });
                currentColorIndex++;
                canvas.add(rect);
                canvas.setActiveObject(rect);

                canvas.on('mouse:move', function(opt) {
                    if (!isDrawing) return;
                    const pointer = canvas.getPointer(opt.e);
                    const activeObject = canvas.getActiveObject();
                    activeObject.set({
                        width: Math.abs(pointer.x - activeObject.left),
                        height: Math.abs(pointer.y - activeObject.top)
                    });
                    activeObject.setCoords();
                    canvas.renderAll();
                });

                canvas.on('mouse:up', function() {
                    isDrawing = false;
                    canvas.off('mouse:move');
                });
            }
        });

        // Undo/Redo functionality
        const state = [];
        let mods = 0;
        canvas.on('object:added', saveState);
        canvas.on('object:removed', saveState);
        canvas.on('object:modified', saveState);

        function saveState() {
            mods += 1;
            if (mods < state.length) {
                state.length = mods;
            }
            state.push(JSON.stringify(canvas));
            recordAnnotation(video.currentTime);
        }

        function undo() {
            if (mods > 0) {
                mods -= 1;
                canvas.loadFromJSON(state[mods]);
                canvas.renderAll();
            }
        }

        function redo() {
            if (mods < state.length - 1) {
                mods += 1;
                canvas.loadFromJSON(state[mods]);
                canvas.renderAll();
            }
        }

        // Synchronize canvas size with video size
        const videoContainer = document.getElementById('video-container');
        const video = document.getElementById('video');
        const fabricCanvas = document.getElementById('canvas');

        video.addEventListener('loadedmetadata', () => {
            fabricCanvas.width = video.clientWidth;
            fabricCanvas.height = video.clientHeight;
            canvas.setWidth(video.clientWidth);
            canvas.setHeight(video.clientHeight);
        });

        // Event listener for video pause
        video.addEventListener('pause', () => {
            canvas.isDrawingMode = true; // Enable drawing mode when video is paused
            fabricCanvas.style.pointerEvents = 'auto'; // Enable pointer events on canvas
        });

        // Event listener for video play
        video.addEventListener('play', () => {
            canvas.isDrawingMode = false; // Disable drawing mode when video is playing
            fabricCanvas.style.pointerEvents = 'none'; // Disable pointer events on canvas
        });

        // Event listener for video time update
        video.addEventListener('timeupdate', () => {
            showAnnotationsAtCurrentTime(video.currentTime);
        });

        // Function to record annotation
        function recordAnnotation(time) {
            const annotation = {
                time: time,
                content: JSON.stringify(canvas.toJSON())
            };
            annotations.push(annotation);
            updateAnnotationsList();
            updateTimelineIcon(time);
            const timeline = document.getElementById('timeline');
            const tick = timeline.querySelector(`.tick[data-time='${Math.floor(time)}']`);
            if (tick) {
                const icon = tick.querySelector('.icon');
                if (icon && icon.querySelector('img').alt === 'Pencil') {
                    const pencilPointer = document.getElementById('pencil-pointer');
                    pencilPointer.style.display = 'block';
                    console.log('pointer placed')
                    pencilPointer.style.top = `${icon.offsetTop - 20}px`; // Adjust top position as needed
                    pencilPointer.style.left = `${icon.offsetLeft}px`; // Adjust left position as needed
                }
            }
                 // Hide pointer icon after a delay (if needed)
            setTimeout(() => {
                const pencilPointer = document.getElementById('pencil-pointer');
                pencilPointer.style.display = 'none';
            }, 2000); // Adjust delay (in milliseconds) as needed
        
        }

        // // Function to update the annotations list in the sidebar
        // function updateAnnotationsList() {
        //     const annotationsList = document.getElementById('annotations-list');
        //     annotationsList.innerHTML = '';
        //     annotations.forEach((annotation, index) => {
        //         const listItem = document.createElement('li');
        //         listItem.textContent = `Annotation at ${annotation.time.toFixed(2)}s`;
        //         listItem.addEventListener('click', () => {
        //             loadAnnotation(index);
        //         });
        //         annotationsList.appendChild(listItem);
        //     });
        // }
        function updateAnnotationsList() {
        const annotationsList = document.getElementById('annotations-list');
        annotationsList.innerHTML = '';
        annotations.forEach((annotation, index) => {
            const listItem = document.createElement('li');
            listItem.className = 'annotation-item';
            listItem.textContent = `Annotation at ${annotation.time.toFixed(2)}s`;

            // Create an input box for comments
            const commentInput = document.createElement('input');
            commentInput.type = 'text';
            commentInput.placeholder = 'Add comment';
            commentInput.value = annotation.comment || '';
            commentInput.style.display = 'none'; // Initially hidden
            commentInput.addEventListener('input', function() {
                annotations[index].comment = commentInput.value;
            });
            const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.display = 'none'; // Initially hidden
        cancelButton.addEventListener('click', function() {
            commentInput.style.display = 'none';
            cancelButton.style.display = 'none';
            saveButton.style.display = 'none';
        });

        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.style.display = 'none'; // Initially hidden
        saveButton.addEventListener('click', function() {
            annotations[index].comment = commentInput.value;
            commentInput.style.display = 'none';
            cancelButton.style.display = 'none';
            saveButton.style.display = 'none';
        });
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'annotation-buttons';
        buttonsContainer.appendChild(cancelButton);
        buttonsContainer.appendChild(saveButton);

        listItem.appendChild(commentInput);
        listItem.appendChild(buttonsContainer);
        listItem.addEventListener('click', () => {
            commentInput.style.display = 'block'; // Show the input box when the list item is clicked
            cancelButton.style.display = 'inline-block'; // Show the cancel button
            saveButton.style.display = 'inline-block'; // Show the save button
        });


            // listItem.appendChild(commentInput);
            // listItem.addEventListener('click', () => {
            //     commentInput.style.display = 'block'; // Show the input box when the list item is clicked
                
            // });
            annotationsList.appendChild(listItem);
            
        });
    }
      

        // Function to load a specific annotation
        function loadAnnotation(index) {
            const annotation = annotations[index];
            video.currentTime = annotation.time;
            canvas.loadFromJSON(annotation.content, () => {
                canvas.renderAll();
            });
        }

        // Function to show annotations at the current time
        function showAnnotationsAtCurrentTime(currentTime) {
            canvas.clear();
            annotations.forEach(annotation => {
                if (Math.abs(annotation.time - currentTime) < 0.5) { // Show annotation close to the current time
                    canvas.loadFromJSON(annotation.content, () => {
                        canvas.renderAll();
                    });
                }
            });
        }

        // Function to update the timeline icon at the specific time
        function updateTimelineIcon(time) {
            const timeline = document.getElementById('timeline');
            const ticks = timeline.getElementsByClassName('tick');
            for (let tick of ticks) {
                if (parseInt(tick.dataset.time) === Math.floor(time)) {
                    tick.classList.add('has-drawing');
                }
            }
        }

        function updateTimelineIcons() {
        const timeline = document.getElementById('timeline');
        const ticks = timeline.getElementsByClassName('tick');
        for (let tick of ticks) {
            tick.classList.remove('has-drawing');
            const icon = tick.querySelector('.icon');
            if (icon) {
                icon.style.display = 'none';
            }
        }
        annotations.forEach(annotation => {
            const time = Math.floor(annotation.time);
            const tick = timeline.querySelector(`.tick[data-time='${time}']`);
            if (tick) {
                tick.classList.add('has-drawing');
                const icon = tick.querySelector('.icon');
                if (icon) {
                    icon.style.display = 'block';
                }
            }
        });
    }
    </script>
</body>
</html>