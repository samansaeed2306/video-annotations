<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Tool and Video Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        .tools {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .tools button {
            margin: 5px;
            padding: 5px;
            cursor: pointer;
            border: none;
            background-color: #f0f0f0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 3px;
        }
        .tools button:hover {
            background-color: #e0e0e0;
        }
        .tools button img {
            width: 20px;
            height: 20px;
        }
        #video-container {
            width: 80%; /* Adjust width as needed */
            max-width: 800px; /* Limit maximum width */
            text-align: center; /* Center align video container */
            position: relative;
            margin: 20px auto; /* Center horizontally with some top margin */
        }
        video {
            width: 100%;
            display: block; /* Ensure video fills its container */
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* Ensure video controls are not obstructed */
        }
        .annotations {
            position: fixed;
            right: 10px;
            top: 10px;
            width: 100px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            height: 80%;
            overflow-y: auto;
        }
        .timeline {
            position: relative; /* Make timeline relative to its container */
            width: 80%; /* Fill the width of its container */
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-top: 20px; /* Add some space between video container and timeline */
            overflow: hidden; /* Hide overflow to prevent extra horizontal scroll */
        }
        .timeline .tick {
            display: inline-block;
            width: calc(100% / var(--duration)); /* Adjust width dynamically based on video duration */
            height: 20px;
            background-color: #ccc;
            margin: 0;
            cursor: pointer;
            position: relative;
        }
        .timeline .tick .icon {
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }
        .timeline .tick.has-drawing .icon {
            display: block;
        }
        .timeline .tick.has-drawing .icon img {
            width: 16px;
            height: 16px;
        }
    </style>
</head>
<body>
    <!-- Drawing Tools -->
    <div class="tools">
        <button onclick="drawFreehand()"><img src="icons/freehand.png" alt="Freehand"></button>
        <button onclick="activateRectangleMode()"><img src="icons/rectangle.png" alt="Rectangle"></button>
        <button onclick="activateTextMode()"><img src="icons/text.png" alt="Text"></button>
        <button onclick="activateNoteMode()"><img src="icons/notes.png" alt="Note"></button>
        <button onclick="useEraser()"><img src="icons/eraser.png" alt="Eraser"></button>
        <button onclick="undo()"><img src="icons/undo.png" alt="Undo"></button>
        <button onclick="redo()"><img src="icons/redo.png" alt="Redo"></button>
    </div>

    <!-- Fabric.js Canvas -->
    <div id="video-container">
        <video id="video" controls></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- Annotations Sidebar -->
    <div class="annotations">
        <h3>Annotations</h3>
        <ul id="annotations-list"></ul>
    </div>

    <!-- Timeline -->
    <div class="timeline" id="timeline"></div>

    <!-- Shaka Player -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/3.1.0/shaka-player.compiled.js"></script>

    <script>
        let annotations = [];
        let currentColorIndex = 0;
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];

        // Initialize Shaka Player
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('video');
            const player = new shaka.Player(video);
            const manifestUri = 'https://storage.googleapis.com/shaka-demo-assets/angel-one/dash.mpd';

            player.load(manifestUri).then(function() {
                console.log('The video has now been loaded!');
                setupTimeline(video);
            }).catch(function(error) {
                console.error('Error code', error.code, 'object', error);
            });
        });

        // Setup the timeline UI
        function setupTimeline(video) {
            const timeline = document.getElementById('timeline');
            const duration = Math.floor(video.duration);
            timeline.style.setProperty('--duration', duration); // Set custom CSS property for dynamic width

            for (let i = 0; i < duration; i++) {
                const tick = document.createElement('div');
                tick.classList.add('tick');
                tick.dataset.time = i; // Associate the tick with a specific second of the video
                tick.innerHTML = '<div class="icon"><img src="icons/pencil.png" alt="Pencil"></div>';
                tick.addEventListener('click', function() {
                    console.log(`Clicked on tick at ${i} seconds.`);
                    video.currentTime = i;
                });
                timeline.appendChild(tick);
            }
        }

        // Fabric.js Canvas Initialization
        const canvas = new fabric.Canvas('canvas', {
            selection: false,
            isDrawingMode: false
        });

        // Set the current drawing color
        function setCurrentDrawingColor() {
            if (canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = colors[currentColorIndex % colors.length];
                currentColorIndex++;
            }
        }

        // Drawing functionality
        let drawingMode = '';
        let isDrawing = false;

        function drawFreehand() {
            canvas.isDrawingMode = true;
            drawingMode = '';
            setCurrentDrawingColor(); // Set new color for each new drawing
        }

        function activateRectangleMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'rectangle';
            setCurrentDrawingColor(); // Set new color for each new drawing
        }

        function activateTextMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'text';
            const text = new fabric.Textbox('Type here', {
                left: 50,
                top: 50,
                fontSize: 20,
                fontFamily: 'Arial',
                fill: colors[currentColorIndex % colors.length],
                width: 200
            });
            currentColorIndex++;
            canvas.add(text).setActiveObject(text);
        }

        function activateNoteMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'note';
            const note = new fabric.Textbox('Note here', {
                left: 50,
                top: 50,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: colors[currentColorIndex % colors.length],
                backgroundColor: '#ffffcc',
                width: 200
            });
            currentColorIndex++;
            canvas.add(note).setActiveObject(note);
        }

        function useEraser() {
            canvas.isDrawingMode = false;
            canvas.on('mouse:down', function(event) {
                if (event.target) {
                    canvas.remove(event.target);
                }
            });
        }

        canvas.on('mouse:down', function(opt) {
            if (drawingMode === 'rectangle') {
                isDrawing = true;
                const pointer = canvas.getPointer(opt.e);
                const rect = new fabric.Rect({
                    left: pointer.x,
                    top: pointer.y,
                    width: 0,
                    height: 0,
                    fill: 'transparent',
                    stroke: colors[currentColorIndex % colors.length],
                    strokeWidth: 2
                });
                currentColorIndex++;
                canvas.add(rect);
                canvas.setActiveObject(rect);

                canvas.on('mouse:move', function(opt) {
                    if (!isDrawing) return;
                    const pointer = canvas.getPointer(opt.e);
                    const activeObject = canvas.getActiveObject();
                    activeObject.set({
                        width: Math.abs(pointer.x - activeObject.left),
                        height: Math.abs(pointer.y - activeObject.top)
                    });
                    activeObject.setCoords();
                    canvas.renderAll();
                });

                canvas.on('mouse:up', function() {
                    isDrawing = false;
                    canvas.off('mouse:move');
                });
            }
        });

        // Undo/Redo functionality
        const state = [];
        let mods = 0;
        canvas.on('object:added', saveState);
        canvas.on('object:removed', saveState);
        canvas.on('object:modified', saveState);

        function saveState() {
            mods += 1;
            if (mods < state.length) {
                state.length = mods;
            }
            state.push(JSON.stringify(canvas));
            recordAnnotation(video.currentTime);
        }

        function undo() {
            if (mods > 0) {
                mods -= 1;
                canvas.loadFromJSON(state[mods]);
                canvas.renderAll();
            }
        }

        function redo() {
            if (mods < state.length - 1) {
                mods += 1;
                canvas.loadFromJSON(state[mods]);
                canvas.renderAll();
            }
        }

        // Synchronize canvas size with video size
        const videoContainer = document.getElementById('video-container');
        const video = document.getElementById('video');
        const fabricCanvas = document.getElementById('canvas');

        video.addEventListener('loadedmetadata', () => {
            fabricCanvas.width = video.clientWidth;
            fabricCanvas.height = video.clientHeight;
            canvas.setWidth(video.clientWidth);
            canvas.setHeight(video.clientHeight);
        });

        // Event listener for video pause
        video.addEventListener('pause', () => {
            canvas.isDrawingMode = true; // Enable drawing mode when video is paused
            fabricCanvas.style.pointerEvents = 'auto'; // Enable pointer events on canvas
        });

        // Event listener for video play
        video.addEventListener('play', () => {
            canvas.isDrawingMode = false; // Disable drawing mode when video is playing
            fabricCanvas.style.pointerEvents = 'none'; // Disable pointer events on canvas
        });

        // Event listener for video time update
        video.addEventListener('timeupdate', () => {
            showAnnotationsAtCurrentTime(video.currentTime);
        });

        // Function to record annotation
        function recordAnnotation(time) {
            const annotation = {
                time: time,
                content: JSON.stringify(canvas.toJSON())
            };
            annotations.push(annotation);
            updateAnnotationsList();
            updateTimelineIcon(time);
        }

        // Function to update the annotations list in the sidebar
        function updateAnnotationsList() {
            const annotationsList = document.getElementById('annotations-list');
            annotationsList.innerHTML = '';
            annotations.forEach((annotation, index) => {
                const listItem = document.createElement('li');
                listItem.textContent = `Annotation at ${annotation.time.toFixed(2)}s`;
                listItem.addEventListener('click', () => {
                    loadAnnotation(index);
                });
                annotationsList.appendChild(listItem);
            });
        }

        // Function to load a specific annotation
        function loadAnnotation(index) {
            const annotation = annotations[index];
            video.currentTime = annotation.time;
            canvas.loadFromJSON(annotation.content, () => {
                canvas.renderAll();
            });
        }

        // Function to show annotations at the current time
        function showAnnotationsAtCurrentTime(currentTime) {
            canvas.clear();
            annotations.forEach(annotation => {
                if (Math.abs(annotation.time - currentTime) < 0.5) { // Show annotation close to the current time
                    canvas.loadFromJSON(annotation.content, () => {
                        canvas.renderAll();
                    });
                }
            });
        }

        // Function to update the timeline icon at the specific time
        function updateTimelineIcon(time) {
            const timeline = document.getElementById('timeline');
            const ticks = timeline.getElementsByClassName('tick');
            for (let tick of ticks) {
                if (parseInt(tick.dataset.time) === Math.floor(time)) {
                    tick.classList.add('has-drawing');
                }
            }
        }
    </script>
</body>
</html>