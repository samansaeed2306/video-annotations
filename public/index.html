<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Tool and Video Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.5.0/fabric.min.js"></script>
    <style>
        h3 {
            color: #ffffff;
            padding-left: 80px;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #485056;
        }
        .tools {
            position: fixed;
            top: 10px;
            left: 40%;
            z-index: 1000;
            background-color: #485056;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .tools button {
            margin: 5px;
            padding: 5px;
            cursor: pointer;
            background-color: #d5b211;
        }
        .tools button:hover {
            background-color: #e0e0e0;
        }
        .tools button img {
            width: 20px;
            height: 20px;
        }
        #video-container {
            width: 80%;
            max-width: 800px;
            padding-top: 600px;
            text-align: center;
            position: relative;
            margin: 20px auto;
        }
        video {
            width: 100%;
            display: block;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .annotations {
            position: fixed;
            right: 10px;
            top: 10px;
            width: 250px;
            background-color: #0f0e0e;
            border: 0.5px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            padding-right: 35px;
            height: 100%;
            overflow-y: auto;
        }
        .annotations ul li {
            color: white;
        }
        .annotation-item {
            background-color: black;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            color: white;
        }
        .annotation-item input {
            width: calc(100% - 20px);
            margin-top: 10px;
        }
        .annotation-buttons {
            text-align: right;
            margin-top: 5px;
        }
        .annotation-buttons button {
            margin-left: 5px;
        }
        .timeline {
            position: relative;
            width: 80%;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        .timeline .tick {
            display: inline-block;
            width: calc(100% / var(--frames));
            height: 20px;
            background-color: #ccc;
            margin: 0;
            cursor: pointer;
            position: relative;
        }
        .timeline .tick .icon {
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }
        .timeline .tick.has-drawing .icon {
            display: block;
        }
        .timeline .tick.has-drawing .icon img {
            width: 16px;
            height: 16px;
        }
        .pointer {
            position: absolute;
            height: 20px;
            width: 1.5px;
            background-color: rgb(187, 255, 0);
            cursor: ew-resize;
        }
    </style>
</head>
<body>
    <!-- Drawing Tools -->
    <div class="tools">
        <button onclick="drawFreehand()"><img src="icons/freehand.png" alt="Freehand"></button>
        <button onclick="activateRectangleMode()"><img src="icons/rectangle.png" alt="Rectangle"></button>
        <button onclick="activateTextMode()"><img src="icons/text.png" alt="Text"></button>
        <button onclick="activateNoteMode()"><img src="icons/notes.png" alt="Note"></button>
        <button onclick="useEraser()"><img src="icons/eraser.png" alt="Eraser"></button>
        <button onclick="undo()"><img src="icons/undo.png" alt="Undo"></button>
        <button onclick="redo()"><img src="icons/redo.png" alt="Redo"></button>
        <button onclick="unpickTool()"><img src="icons/unpick.png" alt="Unpick"></button>
    </div>

    <!-- Fabric.js Canvas -->
    <div id="video-container">
        <video id="video" controls></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- Annotations Sidebar -->
    <div class="annotations">
        <h3>Annotations</h3>
        <ul id="annotations-list"></ul>
    </div>

    <!-- Timeline -->
    <div class="timeline" id="timeline"></div>

    <!-- Shaka Player -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/3.1.0/shaka-player.compiled.js"></script>

    <script>
        let annotations = [];
        let currentColorIndex = 0;
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
        
        // Initialize Shaka Player
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('video');
            const player = new shaka.Player(video);
            const manifestUri = 'https://storage.googleapis.com/shaka-demo-assets/angel-one/dash.mpd';

            player.load(manifestUri).then(function() {
                console.log('The video has now been loaded!');
                setupTimeline(video);
            }).catch(function(error) {
                console.error('Error code', error.code, 'object', error);
            });
        });

        function setupTimeline(video) {
            const timeline = document.getElementById('timeline');
            const fps = 30; // Assuming the video has 30 frames per second
            video.addEventListener('loadedmetadata', function() {
                const totalFrames = Math.floor(video.duration * fps);
                timeline.style.setProperty('--frames', totalFrames); // Set custom CSS property for dynamic width

                for (let i = 0; i < totalFrames; i++) {
                    const tick = document.createElement('div');
                    tick.classList.add('tick');
                    tick.dataset.frame = i; // Set the dataset.frame attribute

                    // Add pencil icon and setup drag events
                    const icon = document.createElement('div');
                    icon.classList.add('icon');
                    const img = document.createElement('img');
                    img.src = 'icons/pencil.png';
                    img.alt = 'Pencil';
                    icon.appendChild(img);
                    tick.appendChild(icon);

                    tick.addEventListener('click', function() {
                        console.log(`Clicked on tick at frame ${i}.`);
                        video.currentTime = i / fps;
                    });

                    // Add drag events to the pencil icon
                    img.addEventListener('dragstart', handleDragStart);
                    tick.addEventListener('dragover', handleDragOver);
                    tick.addEventListener('drop', handleDrop);
                    img.setAttribute('draggable', true);

                    timeline.appendChild(tick);
                }
                updateTimelineIcons();
            });
        }

        // Function to handle drag start
        function handleDragStart(event) {
            const dragFrame = event.target.parentNode.parentNode.dataset.frame;
            console.log('Drag start:', dragFrame);
            event.dataTransfer.setData('text/plain', dragFrame);
        }

        function handleDragOver(event) {
            console.log('Drag over:', event.target.dataset.frame);
            event.preventDefault();
        }

        function handleDrop(event) {
           
            
    // Your existing drop logic here
            console.log('Drop:', event.target.dataset.frame);
            event.preventDefault();
            const oldFrame = event.dataTransfer.getData('text/plain');
            const newFrame = event.target.dataset.frame;
            moveAnnotation(oldFrame, newFrame);

            // Remove the pencil icon from the old tick
            const oldTick = document.querySelector(`.tick[data-frame='${oldFrame}'] .icon`);
            if (oldTick) {
                oldTick.style.display = 'none';
            }
        }

        // Fabric.js Canvas Initialization
        const canvas = new fabric.Canvas('canvas', {
            selection: false,
            isDrawingMode: false
        });

        function moveAnnotation(oldFrame, newFrame) {
            console.log('Moving annotation from', oldFrame, 'to', newFrame);
            oldFrame = parseInt(oldFrame);
            newFrame = parseInt(newFrame);

            // Find the annotation to move
            let annotationIndex = annotations.findIndex(annotation => Math.floor(annotation.frame) === oldFrame);
            if (annotationIndex !== -1) {
                const annotation = annotations[annotationIndex];
                annotation.frame = newFrame;
                annotations.splice(annotationIndex, 1, annotation); // Update annotation frame in the array

                // Remove the annotation from the canvas at the old frame
                canvas.forEachObject(obj => {
                    if (obj.frame === oldFrame) {
                        canvas.remove(obj);
                    }
                });

                // Load the annotation onto the canvas at the new frame
                annotations.forEach(ann => {
                    if (Math.floor(ann.frame) === newFrame) {
                        canvas.loadFromJSON(ann.content, () => {
                            canvas.renderAll();
                        });
                    }
                });

                // Update UI or canvas accordingly
                updateAnnotationsList();
                updateTimelineIcons();
            }
        }
        function showAnnotationsAtFrame(frameNumber) {
            canvas.clear();
            annotations.forEach(annotation => {
                if (annotation.frame === frameNumber) {
                    canvas.loadFromJSON(annotation.content, canvas.renderAll.bind(canvas));
                }
            });
        }
        // Set the current drawing color
        function setCurrentDrawingColor() {
            if (canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = colors[currentColorIndex % colors.length];
                currentColorIndex++;
            }
        }

        // Drawing functionality
        let drawingMode = '';
        let isDrawing = false;

        function drawFreehand() {
            canvas.isDrawingMode = true;
            drawingMode = '';
            setCurrentDrawingColor(); // Set new color for each new drawing
        }

        function activateRectangleMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'rectangle';
            setCurrentDrawingColor(); // Set new color for each new drawing
        }

        function activateTextMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'text';
            const text = new fabric.Textbox('Type here', {
                left: 50,
                top: 50,
                fontSize: 20,
                fontFamily: 'Arial',
                fill: colors[currentColorIndex % colors.length],
                width: 200
            });
            currentColorIndex++;
            canvas.add(text).setActiveObject(text);
        }

        function activateNoteMode() {
            canvas.isDrawingMode = false;
            drawingMode = 'note';
            const note = new fabric.Textbox('Note here', {
                left: 50,
                top: 50,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: colors[currentColorIndex % colors.length],
                backgroundColor: '#ffffcc',
                width: 200
            });
            currentColorIndex++;
            canvas.add(note).setActiveObject(note);
        }

        function useEraser() {
            canvas.isDrawingMode = false;
            canvas.on('mouse:down', function(event) {
                if (event.target) {
                    canvas.remove(event.target);
                }
            });
        }

        function unpickTool() {
            canvas.isDrawingMode = false;
            canvas.defaultCursor = 'default';
            canvas.selection = true;
        }

        canvas.on('mouse:down', function(opt) {
            if (drawingMode === 'rectangle') {
                isDrawing = true;
                const pointer = canvas.getPointer(opt.e);
                const rect = new fabric.Rect({
                    left: pointer.x,
                    top: pointer.y,
                    width: 0,
                    height: 0,
                    fill: 'transparent',
                    stroke: colors[currentColorIndex % colors.length],
                    strokeWidth: 2
                });
                currentColorIndex++;
                canvas.add(rect);
                canvas.setActiveObject(rect);

                canvas.on('mouse:move', function(opt) {
                    if (!isDrawing) return;
                    const pointer = canvas.getPointer(opt.e);
                    const activeObject = canvas.getActiveObject();
                    activeObject.set({
                        width: Math.abs(pointer.x - activeObject.left),
                        height: Math.abs(pointer.y - activeObject.top)
                    });
                    activeObject.setCoords();
                    canvas.renderAll();
                });
            }
        });

        canvas.on('mouse:up', function() {
            isDrawing = false;
            canvas.off('mouse:move');
            saveAnnotation();
        });

        function saveAnnotation() {
            const frame = Math.floor(document.getElementById('video').currentTime * 30); // Assuming 30 fps
            const content = JSON.stringify(canvas);

            const annotation = {
                frame: frame,
                content: content
            };

            annotations.push(annotation);
            updateAnnotationsList();
            updateTimelineIcons();
        }
        function framesToSeconds(frames, frameRate) {
            return frames / frameRate;
        }

        function updateAnnotationsList() {
    const annotationsList = document.getElementById('annotations-list');
    annotationsList.innerHTML = '';
    annotations.forEach((annotation, index) => {
        const listItem = document.createElement('li');
        listItem.className = 'annotation-item';
        listItem.textContent = `Annotation at ${Math.floor(framesToSeconds(annotation.frame,30))}s`;

        // Create an input box for comments
        const commentInput = document.createElement('input');
        commentInput.type = 'text';
        commentInput.placeholder = 'Add comment';
        commentInput.value = annotation.comment || '';
        commentInput.style.display = 'none'; // Initially hidden
        commentInput.addEventListener('input', function() {
            annotations[index].comment = commentInput.value;
        });

        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.display = 'none'; // Initially hidden
        cancelButton.addEventListener('click', function() {
            commentInput.style.display = 'none';
            cancelButton.style.display = 'none';
            saveButton.style.display = 'none';
        });

        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.style.display = 'none'; // Initially hidden
        saveButton.addEventListener('click', function() {
            annotations[index].comment = commentInput.value;
            commentInput.style.display = 'none';
            cancelButton.style.display = 'none';
            saveButton.style.display = 'none';
        });

        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'annotation-buttons';
        buttonsContainer.appendChild(cancelButton);
        buttonsContainer.appendChild(saveButton);

        listItem.appendChild(commentInput);
        listItem.appendChild(buttonsContainer);
        listItem.addEventListener('click', () => {
            commentInput.style.display = 'block'; // Show the input box when the list item is clicked
            cancelButton.style.display = 'inline-block'; // Show the cancel button
            saveButton.style.display = 'inline-block'; // Show the save button
        });

        annotationsList.appendChild(listItem);
    });
}
function loadAnnotations(frameNumber) {
    // Clear the canvas first
    canvas.clear();
    
    // Find the annotation(s) corresponding to the given frame number
    annotations.forEach(annotation => {
        if (annotation.frame === frameNumber) {
            console.log(`Loading annotation: ${annotation.frame}`);
            canvas.loadFromJSON(annotation.content, canvas.renderAll.bind(canvas));
        }
    });
}



        function deleteAnnotation(frame) {
            annotations = annotations.filter(annotation => annotation.frame !== frame);
            canvas.forEachObject(obj => {
                if (obj.frame === frame) {
                    canvas.remove(obj);
                }
            });
            updateAnnotationsList();
            updateTimelineIcons();
        }

        function updateTimelineIcons() {
            const ticks = document.querySelectorAll('.tick');
            ticks.forEach(tick => {
                const frame = parseInt(tick.dataset.frame);
                const hasDrawing = annotations.some(annotation => Math.floor(annotation.frame) === frame);
                if (hasDrawing) {
                    tick.classList.add('has-drawing');
                } else {
                    tick.classList.remove('has-drawing');
                }
            });
        }

        document.getElementById('video').addEventListener('timeupdate', function() {
            const currentFrame = Math.floor(this.currentTime * 30); // Assuming 30 fps
            annotations.forEach(annotation => {
                if (Math.floor(annotation.frame) === currentFrame) {
                    canvas.loadFromJSON(annotation.content, () => {
                        canvas.renderAll();
                    });
                }
            });
        });
    </script>
</body>
</html>